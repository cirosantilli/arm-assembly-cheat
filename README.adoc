= ARM Assembly Cheat
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc: macro
:toclevels: 6
:toc-title:

ARMv7 and <<ARMv8>> assembly userland minimal examples tutorial. Runnable <<asserts,asserts>> on x86 hosts with QEMU user mode or natively on an ARM guests. Nice <<gdb-step-debug>> setup. Tested on Ubuntu 18.04 host and <<rpi2,Raspberry Pi 2>> and <<rpi3,3>> guests. Baremetal setup at: https://github.com/cirosantilli/linux-kernel-module-cheat#baremetal-setup x86 cheat at: https://github.com/cirosantilli/x86-assembly-cheat

toc::[]

== Getting started

On Ubuntu, clone, configure, build QEMU and Binutils from source, run all ARMv7 and ARMv8 examples through QEMU user, and assert that they exit with status 0:

....
git clone --recursive https://github.com/cirosantilli/arm-assembly-cheat
cd arm-assembly-cheat
./download-dependencies
make test
echo $?
....

Expected outcome: the exit status is successful:

....
0
....

For other operating systems, see: <<getting-started-on-non-ubuntu-operating-systems>>.

We compile our own Binutils and QEMU to be able to use the newest ISA features. Those projects build pretty fast (~10 minutes), so it is fine. The cleanest thing would be to also compile GCC with <<crosstool-ng-toolchain>>.

The armv7 examples are all located under the link:v7[] directory. Run all of them:

....
cd v7
make test
echo $?
....

Run just one of them:

....
cd v7
make test-<basename-no-extension>
echo $?
....

E.g.:

....
make test-add
....

will run link:v7/add.S[].

This just tests some assertions, but does not output anything. See: <<asserts>>.

Alternatively, to help with tab completion, the following shortcuts all do the same thing as `make test-add`:

....
./t add
./t add.
./t add.out
....

<<armv8>> examples are all located under the link:v8[] directory. They can be run in the same way as ARMv7 examples:

....
cd v8
make test-movk
....

Just build the examples without running:

....
make
....

Clean the examples:

....
make clean
....

This does not clean QEMU builds themselves. To do that run:

....
make qemu-clean
....

=== Asserts

Almost all example don't output anything, they just assert that the computations are as expected and exit 0 is that was the case.

Failures however output clear error messages.

Try messing with the examples to see them fail, e.g. modify link:v7/add.S[] to contain:

....
mov r0, #1
add r1, r0, #2
ASSERT_EQ(r1, 4)
....

and then watch it fail:

....
cd v7
make test-add
....

with:

....
error 1 at line 12
Makefile:138: recipe for target 'test-add' failed
error 1 at line 12
....

since `1 + 2` tends to equal `3` and not `4`.

So look how nice we are: we even gave you the line number `12` of the failing assert!

=== Getting started on non-Ubuntu operating systems

If you are not on an Ubuntu host machine, here are some ways in which you can use this repo.

==== Other Linux distro hosts

For other Linux distros, you can either:

* have a look at what `download-dependencies` does and adapt it to your distro. It should be easy, then proceed normally.
+
Might fail due to some incompatibility, but likely won't.
* run this repo with <<docker-host-setup,docker>>. Requires you to know some Docker boilerplate, but cannot (?) fail.

===== Docker host setup

....
sudo apt install docker
sudo docker create -it --name arm-assembly-cheat -w "/host/$(pwd)" -v "/:/host" ubuntu:18.04
sudo docker exec -it arm-assembly-cheat /bin/bash
....

Then inside Docker just add the `--docker` flag to `./download-dependencies` and proceed otherwise normally:

....
./download-dependencies --docker
make test
....

The `download-dependencies` takes a while because `build-dep binutils` is large.

We share the repository between Docker and host, so you can just edit the files on host with your favorite text editor, and then just run them from inside Docker.

TODO: GDB TUI GUI is broken inside Docker due to terminal quirks. Forwarding the port and connecting from host will likely work, but I'm lazy to try it out now.

==== Non-Linux host

For non-Linux systems, the easiest thing to do is to use an Ubuntu virtual machine such as VirtualBox: link:https://askubuntu.com/questions/142549/how-to-install-ubuntu-on-virtualbox[].

Porting is not however impossible because we use the C standard library for portability, see: <<architecture-of-this-repo>>. Pull requests are welcome.

[[rpi2]]
==== Raspberry Pi 2 native

Yay! Let's see if this actually works on real hardware, or if it is just an emulation pipe dream?

We will just compile natively, since I'm not in the mood for cross compilation hell today.

link:https://en.wikipedia.org/wiki/Raspberry_Pi[According to Wikipedia] the Raspberry Pi 2 V 1.1 which I have has a link:https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/README.md[BCM2836] SoC, which has 4 link:https://en.wikipedia.org/wiki/ARM_Cortex-A7[ARM Cortex-A7] cores, which link:https://en.wikipedia.org/wiki/List_of_ARM_microarchitectures[implement ARMv7-A], <<vfp,VFPv4>> and <<neon>>.

Therefore we will only be able to run `v7` examples on that board.

First connect to your Pi through SSH as explained at: https://stackoverflow.com/revisions/39086537/10

Then inside the Pi:

....
sudo apt-get update
sudo apt-get install git make gcc gdb
git clone https://github.com/cirosantilli/arm-assembly-cheat
cd arm-assembly-cheat
cd v7
make NATIVE=y test
make NATIVE=y gdb-add
....

GDB TUI is slightly buggier on the ancient 4.9 toolchain (current line gets different indentation, does not break on the right instruction after `asm_main_after_prologue`, link:https://superuser.com/questions/180512/how-to-turn-off-gdb-tui[cannot leave TUI]), but it might still be usable

The Pi 0 and 1 however have a link:https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/[BCM2835] SoC, which has an ARM1176JZF-S core, which implements the ARMv6Z ISA, which we don't support yet on this repo.

Bibliography: https://raspberrypi.stackexchange.com/questions/1732/writing-arm-assembly-code/87260#87260

[[rpi3]]
==== Raspberry Pi 3 native

The Raspberry Pi 3 has a link:https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2837/README.md[BCM2837] SoC, which has 4 link:https://en.wikipedia.org/wiki/ARM_Cortex-A53[Cortex A53] cores, which implement ARMv8-A.

However, as of July 2018, there is no official ARMv8 image for the Pi 3, the same ARMv7 image is provided for both: https://raspberrypi.stackexchange.com/questions/43921/raspbian-moving-to-64-bit-mode

Then we look at the following threads:

* https://raspberrypi.stackexchange.com/questions/49466/raspberry-pi-3-and-64-bit-kernel-differences-between-armv7-and-armv8
* https://raspberrypi.stackexchange.com/questions/77693/enabling-armv8-on-raspberry-pi-3-b

which lead us to this 64-bit Debian based distro for the Pi: https://github.com/bamarni/pi64

So first we flash pi64's link:https://github.com/bamarni/pi64/releases/download/2017-07-31/pi64-lite.zip[2017-07-31 release], and then do exactly the same as for the Raspberry Pi 2, except that you must go into the `v8` directory instead of `v7`.

TODO: can we run the `v7` folder in ARMv8? First I can't even compile it. Related: https://stackoverflow.com/questions/21716800/does-gcc-arm-linux-gnueabi-build-for-a-64-bit-target For runtime: https://stackoverflow.com/questions/22460589/armv8-running-legacy-32-bit-applications-on-64-bit-os

=== GDB step debug

Debug one example with GDB:

....
make gdb-add
....

Shortcut:

....
./t -g add
....

This leaves us right at the end of the prologue of `asm_main` in link:https://sourceware.org/gdb/onlinedocs/gdb/TUI.html[GDB TUI mode], which is at the start of the assembly code in the `.S` file.

Stop on a different symbol instead:

....
make GDB_BREAK=main gdb-add
....

Shortcut:

....
./t -b main -g add
....

It is not possible to restart the running program from GDB as in `gdbserver --multi` unfortunately: https://stackoverflow.com/questions/51357124/how-to-restart-qemu-user-mode-programs-from-the-gdb-stub-as-in-gdbserver-multi

Quick GDB tips:

* print a register:
+
....
i r r0
....
+
Bibliography: https://stackoverflow.com/questions/5429137/how-to-print-register-values-in-gdb
* print an array of 4 32-bit integers in hex:
+
....
p/x (unsigned[4])my_array_0
....
+
Bibliography: https://stackoverflow.com/questions/32300718/printing-array-from-bss-in-gdb
* print the address of a variable:
+
....
p &my_array_0
....

Bibliography: https://stackoverflow.com/questions/20590155/how-to-single-step-arm-assembler-in-gdb-on-qemu/51310791#51310791

==== Advanced usage

The default setup is opinionated and assumes that your are a newb: it ignores your `.gdbinit` and puts you in TUI mode.

However, you will sooner or later notice that TUI is crappy print on break Python scripts are the path of light, e.g. link:https://github.com/cyrus-and/gdb-dashboard[GDB dashboard].

In order to prevent our opinionated defaults get in the way of your perfect setup, use:

....
make GDB_EXPERT=y gdb-add
....

or the shortcut:

....
./t -G add
....

=== Disassemble

Even though <<gdb-step-debug>> can already disassemble instructions for us, it is sometimes useful to have the disassembly in a text file for further examination.

Disassemble all examples:

....
make -j `nproc` objdump
....

Disassemble one example:

....
make add.objdump
....

Examine one disassembly:

....
less -p asm_main add.objdump
....

This jumps directly to `asm_main`, which is what you likely want to see.

Disassembly is still useful even though we are writing assembly because the assembler can do some non-obvious magic that we want to understand.

=== crosstool-NG toolchain

Currently we build just Binutils from source, but use the host GCC to save time.

This could lead to incompatibilities, although we haven't observed any so far.

link:https://github.com/crosstool-ng/crosstool-ng[crosstool-NG] is a set of scripts that makes it easy to obtain a cross compiled GCC. Ideally we should track it here as a submodule and automate from there.

You can build the toolchain with crosstool-NG as explained at: https://stackoverflow.com/revisions/51310756/6

Then run this repo with:

....
make \
  CTNG=crosstool-ng/.build/ct_prefix \
  PREFIX=arm-cortex_a15-linux-gnueabihf \
  test \
;
....

=== Build the documentation

If you don't like reading on GitHub, the HTML documentation can be generated from the README with:

....
make doc
xdg-open out/README.html
....

== ARM assembly basics

=== Registers

Examples: link:v7/regs.S[]

Bibliography: <<armarm7>> A2.3 "ARM core registers".

=== GAS syntax

==== Immediates

Full explanation: https://stackoverflow.com/questions/21652884/is-the-hash-required-for-immediate-values-in-arm-assembly/51987780#51987780

Examples:

* link:v7/immediates.S[]
* link:v8/immediates.S[]

==== Comments

Full explanation: https://stackoverflow.com/questions/15663280/how-to-make-the-gnu-assembler-use-a-slash-for-comments/51991349#51991349

Examples:

* link:v7/comments.S[]
* link:v8/comments.S[]

==== .n and .w suffixes

When reading <<disassemble,disassembly>>, many instructions have either a `.n` or `.w` suffix.

`.n` means narrow, and stands for the Thumb encoding of an instructions, while `.w` means wide and stands for the ARM encoding.

Bibliography: https://stackoverflow.com/questions/27147043/n-suffix-to-branch-instruction

== Instructions

Grouping loosely based on that of the <<armarm7>> Chapter A4 "The Instruction Sets".

=== Branch instructions

==== b

Unconditional branch.

Example: link:v7/b.S[]

The encoding stores `pc` offsets in 24 bits. The destination must be a multiple of 4, which is easy since all instructions are 4 bytes.

This allows for 26 bit long jumps, which is 64 MiB.

TODO: what to do if we want to jump longer than that?

==== beq

Branch if equal based on the status registers.

Example: link:v7/beq.S[].

The family of instructions includes:

* `beq`: branch if equal
* `bne`: branch if not equal
* `ble`: less or equal
* `bge`: greater or equal
* `blt`: less than
* `bgt`: greater than

==== bl

Branch with link, i.e. branch and store the return address on the `rl` register.

Example: link:v7/bl.S[]

This is the major way to make function calls.

The current ARM / Thumb mode is encoded in the least significant bit of lr.

===== bx

`bx`: branch and switch between ARM / Thumb mode, encoded in the least significant bit of the given register.

`bx lr` is the main way to return from function calls after a `bl` call.

Since `bl` encodes the current ARM / Thumb in the register, `bx` keeps the mode unchanged by default.

==== cbz

Compare and branch if zero.

Example: link:v8/cbz.S[]

Only in ARMv8 and ARMv7 Thumb mode, not in armv7 ARM mode.

==== Conditional execution

Weirdly, <<b>> and family are not the only instructions that can execute conditionally on the flags: the same also applies to most instructions, e.g. `add`.

Example: link:v7/cond.S[]

Just add the usual `eq`, `ne`, etc. suffixes just as for `b`.

The list of all extensions is documented at <<armarm7>> "A8.3 Conditional execution".

=== Load and store instructions

In ARM, there are only two instruction families that do memory access: <<ldr>>  to load and <<str>> to store.

Everything else works on register and immediates.

This is part of the RISC-y beauty of the ARM instruction set, unlike x86 in which several operations can read from memory, and helps to predict how to optimize for a given CPU pipeline.

This kind of architecture is called a link:https://en.wikipedia.org/wiki/Load/store_architecture[Load/store architecture].

==== ldr

===== ldr magic

The `ldr` assembly directive can automatically create hidden variables and load them from memory with PC relative loads.

Example: link:v7/ldr_magic.S[]

This is done basically because all instructions are 32-bit wide, and there is not enough space to encode 32-bit addresses in them.

Bibliography:

* https://stackoverflow.com/questions/37840754/what-does-an-equals-sign-on-the-right-side-of-a-ldr-instruction-in-arm-mean
* https://stackoverflow.com/questions/17214962/what-is-the-difference-between-label-equals-sign-and-label-brackets-in-ar
* https://stackoverflow.com/questions/14046686/why-use-ldr-over-mov-or-vice-versa-in-arm-assembly

===== Addressing modes

Example: link:v7/address_modes.S[]

Load and store instructions can update the source register with the following modes:

* offset: add an offset, don't change the address register. Notation:
+
....
ldr r1, [r0, #4]
....
* pre-indexed: change the address register, and then use it modified. Notation:
+
....
ldr r1, [r0, #4]!
....
* post-indexed: use the address register unmodified, and then modify it. Notation:
+
....
ldr r1, [r0] #4
....

The offset itself can come from the following sources:

* immediate
* register
* scaled register: left shift the register and use that as an offset

The indexed modes are convenient to loop over arrays.

Bibliography: <<armarm7>>:

* A4.6.5 "Addressing modes"
* A8.5 "Memory accesses"

====== Loop over array

As an application of the post-indexed addressing mode, let's increment an array.

Example: link:v7/inc_array.S[]

===== ldr and ldrb

There are `ldr` variants that load less than full 4 bytes:

* link:v7/ldrb.S[]: load byte
* link:v7/ldrh.S[]: load half word

===== ldr ARMv8

Unlike in ARMv7, the target register cannot be SP or PC, otherwise assembly fails with:

....
Error: operand 1 should be an integer register -- `ldr sp,=0x1111222233334444'
....

Examples:

* link:v7/ldr_sp.S[]
* link:v8/ldr_sp.S[]

TODO rationale.

==== str

Store from memory into registers.

Example: link:v7/str.S[]

Basically everything that applies to <<ldr>> also applies here so we won't go into much detail.

==== ldmia

Pop values form stack into the register and optionally update the address register.

`stmdb` is the push version.

Example: link:v7/ldmia.S[]

The mnemonics stand for:

* `stmdb`: STore Multiple Decrement Before
* `ldmia`: LoaD Multiple Increment After

Example: link:v7/push.S[]

`push` and `pop` are just mnemonics `stdmdb` and `ldmia` using the stack pointer `sp` as address register:

....
stmdb sp!, reglist
ldmia sp!, reglist
....

The `!` indicates that we want to update the register.

The registers are encoded as single bits inside the instruction: each bit represents one register.

As a consequence, the push order is fixed no matter how you write the assembly instruction: there is just not enough space to encode ordering.

AArch64 loses those instructions, likely because it was not possible anymore to encode all registers: http://stackoverflow.com/questions/27941220/push-lr-and-pop-lr-in-arm-arch64 and replaces them with `stp` and `ldp`.

=== Data processing instructions

Arithmetic:

* link:v7/add.S[]. We use this simple instruction to explain syntax common to most data processing instructions, so have a good look at that file.
* link:v7/mul.S[]
* link:v7/sub.S[]
* link:v7/tst.S[]

==== Bitwise

* link:v7/and.S[]
* `eor`: exclusive OR
* `oor`: OR
* link:v7/clz.S[]: count leading zeroes

===== bic

Bitwise Bit Clear: clear some bits.

....
dest = `left & ~right`
....

Example: link:v7/bic.S[]

==== mov

Move an immediate to a register, or a register to another register.

Cannot load from or to memory, since only the `ldr` and `str` instruction families can do that in ARM: <<load-and-store-instructions>>

Example: link:v7/mov.S[]

Since every instruction <<instruction-length,has a fixed 4 byte size>>, there is not enough space to encode arbitrary 32-bit immediates in a single instruction, since some of the bits are needed to actually encode the instruction itself.

The solutions to this problem are mentioned at:

* https://stackoverflow.com/questions/38689886/loading-32-bit-values-to-a-register-in-arm-assembly
* https://community.arm.com/processors/b/blog/posts/how-to-load-constants-in-assembly-for-arm-architecture

Summary of solutions:

* <<movw-and-movt>>
* place it in memory. But then how to load the address, which is also a 32-bit value?
** use pc-relative addressing if the memory is close enough
** use `orr` encodable shifted immediates

The blog article summarizes nicely which immediates can be encoded and the design rationale:

____
An Operand 2 immediate must obey the following rule to fit in the instruction: an 8-bit value rotated right by an even number of bits between 0 and 30 (inclusive). This allows for constants such as 0xFF (0xFF rotated right by 0), 0xFF00 (0xFF rotated right by 24) or 0xF000000F (0xFF rotated right by 4).

In software - especially in languages like C - constants tend to be small. When they are not small they tend to be bit masks. Operand 2 immediates provide a reasonable compromise between constant coverage and encoding space; most common constants can be encoded directly.
____

Assemblers however support magic memory allocations which may hide what is truly going on: https://stackoverflow.com/questions/14046686/why-use-ldr-over-mov-or-vice-versa-in-arm-assembly Always ask your friendly disassembly for a good confirmation.

==== movw and movt

Set the higher or lower 16 bits of a register to an immediate in one go.

Example: link:v7/movw.S[]

The ARMv8 version analogue is <<movk>>.

==== Shift suffixes

Most data processing instructions can also optionally shift the second register operand.

Example: link:v7/shift.S[]

The shift types are:

* `lsr` and `lfl`: Logical Shift Right / Left. Insert zeroes.
* `ror`: Rotate Right / Left. Wrap bits around.
* `asr`: Arithmetic Shift Right. Keep sign.

Documented at: <<armarm7>> "A4.4.1 Standard data-processing instructions"

==== S suffix

The `S` suffix, present on most <<data-processing-instructions>>, makes the instruction also set the Status register flags that control conditional jumps.

If the result of the operation is `0`, then it triggers `beq`, since comparison is a subtraction, with success on 0.

Example: link:v7/s_suffix.S[]

==== ubfm

Unsigned Bitfield Move.

____
copies any number of low-order bits from a source register into the same number of
adjacent bits at any position in the destination register, with zeros in the upper and lower bits.
____

Example: link:v8/ubfm.S[]

Operation:

....
dest = (src & ((1 << width) - 1)) >> lsb;
....

Bibliography: https://stackoverflow.com/questions/8366625/arm-bit-field-extract

===== ubfx

Alias for:

....
UBFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)
....

=== Miscellaneous instructions

==== nop

There are a few different ways to encode `nop`, notably `mov` a register into itself, and a dedicated miscellaneous instruction.

Example: link:v7/nop.S[]

Try disassembling the executable to see what the assembler is emitting:

....
gdb-multiarch -batch -ex 'arch arm' -ex "file v7/nop.out" -ex "disassemble/rs asm_main_after_prologue"
....

Bibliography: https://stackoverflow.com/questions/1875491/nop-for-iphone-binaries

== Instruction encoding

Understanding the basics of instruction encodings is fundamental to help you to remember what instructions do and why some things are possible or not.

=== Instruction length

Every ARMv7 instruction is 4 bytes long.

This RISC-y design likely makes processor design easier and allows for certain optimizations, at the cost of slightly more complex assembly. Totally worth it.

<<Thumb>> is an alternative encoding.

=== Thumb

Variable bit encoding where instructions are either 4 or 2 bytes.

In general cannot encode conditional instructions, but <<thumb-2>> can.

Example: link:v7/thumb.S[]

Bibliography:

* https://stackoverflow.com/questions/28669905/what-is-the-difference-between-the-arm-thumb-and-thumb-2-instruction-encodings
* https://reverseengineering.stackexchange.com/questions/6080/how-to-detect-thumb-mode-in-arm-disassembly

=== Thumb-2

Newer version of thumb that allows encoding almost all instructions, TODO example.

Bibliography: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0471i/CHDFEDDB.html

[[aapcs]]
== Calling convention

Call C standard library functions from assembly:

....
make test-c_from_asm
....

Output:

....
hello puts
hello printf 12345678
....

Source: link:v7/c_from_asm.S[]

ARM Architecture Procedure Call Standard (AAPCS) is the name that ARM Holdings gives to the calling convention.

Official specification: http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf

Bibliography:

* https://en.wikipedia.org/wiki/Calling_convention#ARM_(A32) Wiki contains the master list as usual.
* http://stackoverflow.com/questions/8422287/calling-c-functions-from-arm-assembly
* http://stackoverflow.com/questions/261419/arm-to-c-calling-convention-registers-to-save
* https://stackoverflow.com/questions/10494848/arm-whats-the-difference-between-apcs-and-aapcs-abi

== Inline assembly

Somewhat like x86, but with a few quirks, so let's make a list of what works here.

* link:v7/c/reg_var.c[]
* link:v8/c/reg_var.c[]
* link:v8/c/reg_var_float.c[]

== Linux system calls

Do a `write` and `exit` raw Linux system calls:

....
make -C v7/linux test
make -C v8/linux test
....

Outcome for each:

....
hello syscall v7
hello syscall v8
....

Sources:

* link:v7/linux/hello.S[]
* link:v8/linux/hello.S[]

Unlike most our other examples, which use the C standard library for portability, this one can only be run on Linux.

The syscall numbers are defined at:

* v7: https://github.com/torvalds/linux/blob/v4.17/arch/arm/tools/syscall.tbl
* v8: https://github.com/torvalds/linux/blob/v4.17/include/uapi/asm-generic/unistd.h

Bibliography:

* https://stackoverflow.com/questions/12946958/what-is-the-interface-for-arm-system-calls-and-where-is-it-defined-in-the-linux
* https://stackoverflow.com/questions/45742869/linux-syscall-conventions-for-armv8
* https://reverseengineering.stackexchange.com/questions/16917/arm64-syscalls-table

== ARMv8

In this repository we will document only points where ARMv8 differs from ARMv7 behaviour: so you should likely learn ARMv7 first.

ARMv8 is the 64 bit version of the ARM architecture.

It has two states:

* AArch32: 32-bit legacy compatibility mode, similar to ARMv7
* AArch64: 64-bit mode, the main mode of operation

Great summary of differences from AArch32: <https://en.wikipedia.org/wiki/ARM_architecture#AArch64_features>

ARMv8 was link:https://developer.arm.com/docs/den0024/latest/preface[released in 2013].

Some random ones, TODO create clean examples of them:

* the stack has to 16-byte aligned. Therefore, the main way to push things to stack is `ldp` and  `stp`, which push two 8 byte registers at a time

=== movk

Fill a 64 bit register with 4 16-bit instructions one at a time.

Similar to <<movw-and-movt>> in v7.

Example: link:v8/movk.S[]

Bibliography: https://stackoverflow.com/questions/27938768/moving-a-32-bit-constant-in-arm-arch64-register

=== ARMv8 registers

Example: link:v8/regs.S[]

==== x31

Example: link:v8/x31.S[]

There is no `x31` name, and the encoding can have two different names depending on the instruction:

* `xzr`: zero register:
** https://stackoverflow.com/questions/42788696/why-might-one-use-the-xzr-register-instead-of-the-literal-0-on-armv8
** https://community.arm.com/processors/f/discussions/3185/wzr-xzr-register-s-purpose
* `sp`: stack pointer

Described on <<armarm8>> C1.2.5 "Register names".

=== stp

Push a pair of registers to the stack.

TODO minimal example. Currently used on link:v8/commmon_arch.h[] since it is the main way to restore register state.

== Floating point

=== VFP

Vector Floating Point extension.

Example: link:v7/vfp.S[]

Basically not implemented in ARMv8, the wiki says:

____
Some devices such as the ARM Cortex-A8 have a cut-down VFPLite module instead of a full VFP module, and require roughly ten times more clock cycles per float operation.
____

VFP has several revisions, named as VFPv1, VFPv2, etc. TODO: announcement dates.

As mentioned at: https://stackoverflow.com/questions/37790029/what-is-difference-between-arm64-and-armhf/48954012#48954012 the Linux kernel shows those capabilities in `/proc/cpuinfo` with flags such as `vfp`, `vfpv3` and others, see:

* https://github.com/torvalds/linux/blob/v4.18/arch/arm/kernel/setup.c#L1199
* https://github.com/torvalds/linux/blob/v4.18/arch/arm64/kernel/cpuinfo.c#L95

When a certain version of VFP is present on a CPU, the compiler prefix typically contains the `hf` characters which stands for Hard Float, e.g.: `arm-linux-gnueabihf`. This means that the compiler will emit VFP instructions instead of just using software implementations.

Bibliography:

* [[armarm7]] Appendix D6 "Common VFP Subarchitecture Specification". It is not part of the ISA, but just an extension.
* https://mindplusplus.wordpress.com/2013/06/25/arm-vfp-vector-programming-part-1-introduction/
* https://en.wikipedia.org/wiki/ARM_architecture#Floating-point_(VFP)

=== Advanced SIMD instructions

Examples:

* link:v7/simd.S[]
* link:v8/floating_point.S[]
* link:v8/simd.S[]

The <<armarm8>> specifies floating point support in the main architecture at A1.5 "Advanced SIMD and floating-point support".

The feature is often refered to simply as "SIMD&FP" throughout the manual.

The Linux kernel shows `/proc/cpuinfo` compatibility as `neon`.

Vs <<vfp>>: https://stackoverflow.com/questions/4097034/arm-cortex-a8-whats-the-difference-between-vfp-and-neon

==== SIMD interleaving

Example: link:v8/simd_interleave.S[]

We can load multiple vectors from memory in one instruction.

Note how the vectors are loaded in an interleaved manner: one int for each.

This is why the `ldN` instructions take an argument list denoted by `{}` for the registers, much like armv7 <<ldmia>>.

TODO confirm: can load up to 4 vectors at once.

==== Advanced SIMD instructions bibliography

Non-formal introductory tutorials are extrmerly scarce.

A few good ways to get your hands on some examples include:

* disassemble some minimal floating-point C code
* look through GAS tests under link:https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=tree;f=gas/testsuite/gas/aarch64;hb=00f223631fa9803b783515a2f667f86997e2cdbe[`gas/testsuite/gas/aarch64`]
* https://stackoverflow.com/questions/2851421/is-there-a-good-reference-for-arm-neon-intrinsics
* look into existing assembly optimized libraries:
** https://github.com/projectNe10/Ne10
* https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf tutorial by Mozilla employee, v7 integer only

==== NEON

Just an informal name for the "Avanced SIMD instructions"? Very confusing.

<<armarm8>> F2.9 "Additional information about Advanced SIMD and floating-point instructions" says:

____
The Advanced SIMD architecture, its associated implementations, and supporting software, are commonly referred to as NEON technology.
____

https://developer.arm.com/technologies/neon mentions that is is present on both ARMv7 and ARMv8:

____
NEON technology was introduced to the Armv7-A and Armv7-R profiles. It is also now an extension to the Armv8-A and Armv8-R profiles.
____

==== ARMv8 floating point availability

Support is semi-mandatory:

____
No floating-point or SIMD support. This option is licensed only for implementations targeting specialized markets.
____

Therefore it is in theory optional, but highly available.

This is unlike ARMv7, where floating point is completely optional through <<vfp>>.

==== ARMv7 advanced floating point registers

32 64-bit registers `d0` to `d31`.

Can also be interpreted as 16 128-bit registers: `q0` to `q15`.

==== ARMv8 advanced floating point registers

<<armarm8>> B1.2.1 "Registers in AArch64" describes the registers:

____
32 SIMD&FP registers, `V0` to `V31`. Each register can be accessed as:

* A 128-bit register named `Q0` to `Q31`.
* A 64-bit register named `D0` to `D31`.
* A 32-bit register named `S0` to `S31`.
* A 16-bit register named `H0` to `H31`.
* An 8-bit register named `B0` to `B31`.
____

=== SVE

TODO get assert working:

link:v8/sve.S[]

Scalable Vector Extension.

aarch64 only, newer than <<neon>>.

Added to QEMU use mode in 3.0.0.

TODO announcement date. Possibly 2017: https://alastairreid.github.io/papers/sve-ieee-micro-2017.pdf There is also a 2016 mention: https://community.arm.com/tools/hpc/b/hpc/posts/technology-update-the-scalable-vector-extension-sve-for-the-armv8-a-architecture

The Linux kernel shows `/proc/cpuinfo` compatibility as `sve`.

Official spec: https://developer.arm.com/docs/100891/latest/sve-overview/introducing-sve

==== SVE bibliography

* https://alastairreid.github.io/papers/sve-ieee-micro-2017.pdf paper with some nice few concrete examples, illustrations and rationale. This is the best material I've seen so far.
* https://static.docs.arm.com/dui0965/c/DUI0965C_scalable_vector_extension_guide.pdf
* https://developer.arm.com/products/software-development-tools/hpc/documentation/writing-inline-sve-assembly quick inlining guide

===== SVE spec

<<armarm8>> A1.7 "ARMv8 architecture extensions" says:

____
SVE is an optional extension to ARMv8.2. That is, SVE requires the implementation of ARMv8.2.
____

A1.7.8 "The Scalable Vector Extension (SVE)": then says that only changes to the existing registers are described in that manual, and that you should look instead at the "ARM Architecture Reference Manual Supplement, The Scalable Vector Extension (SVE), for ARMv8-A."

We then download the zip from: https://developer.arm.com/docs/ddi0584/latest/arm-architecture-reference-manual-supplement-the-scalable-vector-extension-sve-for-armv8-a and it contains the PDF: `DDI0584A_d_SVE_supp_armv8A.pdf` which we use here.

That document then describes the SVE instructions and registers.

== Theory

TODO review all of those and move them into the main README. They are from a previous life.

. link:how-to-play-with-arm.md[How to play with ARM]
. link:versions.md[Versions]
.. link:thumb.md[Thumb]
. link:vs-x86.md[Vs x86]
. link:compilers.md[Compilers]
. link:gas.md[GAS]

=== Architecture of this repo

`qemu-arm-static` is used for emulation on x86 hosts. It translates ARM to x86, and forwards system calls to the host kernel.

OS portability is achieved with the C standard library which makes system calls for us: this would in theory work in operating systems other than Linux if you port the build system to them.

Using the standard library also allows us to use its convenient functionality such as `printf` formatting and `memcpy` to check memory.

Non-OS portable examples will be clearly labeled with their OS, e.g.: <<linux-system-calls>>.

These examples show how our infrastructure works:

* link:fail.S[]
* link:v7/hello_driver.S[]
* link:hello_common.S[]

==== C driver

We link all examples against a C program: link:main.c[]. Sample simplified commands:

....
arm-linux-gnueabihf-gcc -c -o 'main.o' 'main.c'
arm-linux-gnueabihf-gcc -c -o 'sub.o' 'sub.S'
arm-linux-gnueabihf-gcc -o 'sub.out' 'sub.o' main.o
....

The C driver then just calls `asm_main`, which each `.S` example implements.

This allows us to easily use the C standard library portably: from the point of view of GCC, everything looks like a regular C program, which does the required glibc initialization before `main()`.
=== Introduction to ARM

The link:https://en.wikipedia.org/wiki/ARM_architecture[ARM architecture] is has been used on the vast majority of mobile phones in the 2010's, and on a large fraction of micro controllers.

It competes with x86 because its implementations are designed for low power consumption, which is a major requirement of the cell phone market.

ARM is generally considered a RISC instruction set, although there are some more complex instructions which would not generally be classified as purely RISC.

ARM is developed by the British funded company ARM Holdings: https://en.wikipedia.org/wiki/Arm_Holdings which originated as a joint venture between Acorn Computers, Apple  and VLSI Technology in 1990.

=== Free implementations

The ARM instruction set is itself protected by patents / copyright / whatever, and you have to pay ARM Holdings a licence to implement it with their own custom Verilog code.

This is the case of many major customers, including many Apple's Ax and Qualcomm Snapdragon chips.

ARM has already sued people in the past for implementing ARM ISA: http://www.eetimes.com/author.asp?section_id=36&doc_id=1287452

http://semiengineering.com/an-alternative-to-x86-arm-architectures/ mentions that:

____
Asanovic joked that the shortest unit of time is not the moment between a traffic light turning green in New York City and the cab driver behind the first vehicle blowing the horn; it’s someone announcing that they have created an open-source, ARM-compatible core and receiving a “cease and desist” letter from a law firm representing ARM.
____

This licensing however does have the following fairness to it: ARM Holdings invents a lot of money in making a great open source software environment for the ARM ISA, so it is only natural that it should be able to get some money from hardware manufacturers for using their ISA.

Patents for very old ISAs however have expired, Amber is one implementation of those: https://en.wikipedia.org/wiki/Amber_%28processor_core%29 TODO does it have any application?

Bibliography: https://www.quora.com/Why-is-it-that-you-need-a-license-from-ARM-to-design-an-ARM-CPU-How-are-the-instruction-sets-protected

== CONTRIBUTING

=== Update QEMU

https://stackoverflow.com/questions/816370/how-do-you-force-a-makefile-to-rebuild-a-target

....
git -C qemu pull
make -B -C v7 qemu
make -B -C v8 qemu
....

If the build fails due to drastic QEMU changes, first do:

....
make qemu-clean
....

Then make sure that the tests still pass:

....
make test
....

== Bibliography

ISA quick references can be found in some places however:

- <https://web.archive.org/web/20161009122630/http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001m/QRC0001_UAL.pdf>

Getting started tutorials:

* http://www.davespace.co.uk/arm/introduction-to-arm/
* https://azeria-labs.com/writing-arm-assembly-part-1/
* https://thinkingeek.com/arm-assembler-raspberry-pi/
* http://bob.cs.sonoma.edu/IntroCompOrg-RPi/app-make.html

=== Official manuals

The official manuals were stored in http://infocenter.arm.com but as of 2017 they started to slowly move to link:https://developer.arm.com[].

Each revision of a document has a "ARM DDI" unique document identifier.

The "ARM Architecture Reference Manuals" are the official canonical ISA documentation document. In this repository, we always reference the following revisions:

Bibliography: https://www.quora.com/Where-can-I-find-the-official-documentation-of-ARM-instruction-set-architectures-ISAs

[[armarm7]]
==== ARMv7 architecture reference manual

ARMv7: https://developer.arm.com/products/architecture/a-profile/docs/ddi0406/latest/arm-architecture-reference-manual-armv7-a-and-armv7-r-edition

We use: DDI 0406C.d: https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf

[[armarm8]]
==== ARMv8 architecture reference manual

https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile

We use: ARM DDI 0487C.a: https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf

==== Programmer’s Guide for ARMv8-A

https://developer.arm.com/docs/den0024/latest/preface

A more terse human readable introduction to the ARM architecture than the reference manuals.

Does not have as many assembly code examples as you'd hope however...

We use: DEN0024A https://static.docs.arm.com/den0024/a/DEN0024A_v8_architecture_PG.pdf

=== Bare metal

This tutorial only covers userland concepts.

However, certain instructions can only be used in higher privilege levels from an operating system itself.

Here is a base setup ARM programming without an operating system, also known as "Bare Metal Programming": https://github.com/cirosantilli/linux-kernel-module-cheat/tree/7d6f8c3884a4b4170aa274b986caae55b1bebaaf#baremetal-setup

Features:

* clean crosstool-NG build for GCC
* C standard library powevered by Newlib
* works on both QEMU and gem5

Here are further links:

* generic:
** https://stackoverflow.com/questions/38914019/how-to-make-bare-metal-arm-programs-and-run-them-on-qemu/50981397#50981397 generic QEMU question
** link:https://github.com/freedomtan/aarch64-bare-metal-qemu/tree/2ae937a2b106b43bfca49eec49359b3e30eac1b1[]: `-M virt` UART bare metal hello world, nothing else, just works
** https://github.com/bravegnu/gnu-eprog Not tested.
** https://stackoverflow.com/questions/29837892/how-to-run-a-c-program-with-no-os-on-the-raspberry-pi/40063032#40063032 no QEMU restriction
** https://github.com/cirosantilli/raspberry-pi-bare-metal-blinker minimal, but not very QEMU friendly however because hard to observe LED: https://raspberrypi.stackexchange.com/questions/56373/is-it-possible-to-get-the-state-of-the-leds-and-gpios-in-a-qemu-emulation-like-t
* raspberry PI:
** https://raspberrypi.stackexchange.com/questions/34733/how-to-do-qemu-emulation-for-bare-metal-raspberry-pi-images/85135#85135 RPI3 specific
** link:https://github.com/bztsrc/raspi3-tutorial[], getting started: https://raspberrypi.stackexchange.com/questions/34733/how-to-do-qemu-emulation-for-bare-metal-raspberry-pi-images/85135#85135
** https://github.com/dwelch67/raspberrypi
** https://github.com/BrianSidebotham/arm-tutorial-rpi
* gem5:
** https://github.com/tukl-msd/gem5.bare-metal bare metal UART example. Tested with: https://stackoverflow.com/questions/43682311/uart-communication-in-gem5-with-arm-bare-metal/50983650#50983650
* games:
** https://github.com/kcsongor/arm-doom PI 1 model B https://www.youtube.com/watch?v=jeHtktKtGYQ
** https://github.com/Tetris-Duel-Team/Tetris-Duel Demo: https://www.youtube.com/watch?v=hTqKRdcKZ9k
** https://github.com/ICTeam28/PiFox rail shooter https://www.youtube.com/watch?v=-5n9IxSQH1M

x86 bare metal tutorial at: https://github.com/cirosantilli/x86-bare-metal-examples
